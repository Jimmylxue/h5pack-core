!(function (e, t) {
	'object' == typeof exports && 'undefined' != typeof module
		? t(exports)
		: 'function' == typeof define && define.amd
		? define(['exports'], t)
		: t(
				((e =
					'undefined' != typeof globalThis
						? globalThis
						: e || self).H5PackBridge = {})
		  )
})(this, function (e) {
	'use strict'
	class t {
		h5packBridge
		moduleName
		constructor(e, t) {
			;(this.h5packBridge = e), (this.moduleName = t)
		}
		async call(e, t) {
			return this.h5packBridge.callNative(this.moduleName, e, t)
		}
		handleError(e, t = 'Operation failed') {
			throw (
				(console.error(`[${this.moduleName}] Error:`, e),
				new Error(e.message || t))
			)
		}
	}
	class r extends t {
		constructor(e) {
			super(e, 'camera')
		}
		async open(e = {}) {
			const t = {
				cameraType: e.cameraType || 'back',
				mediaType: 'photo',
				saveToPhotos: !1,
				...e,
			}
			try {
				return await this.call('open', t)
			} catch (e) {
				return this.handleError(e, 'Failed to open camera')
			}
		}
		async scan() {
			try {
				return await this.call('scan')
			} catch (e) {
				return this.handleError(e, 'Failed to open scan')
			}
		}
		async chooseImage(e = {}) {
			const t = {
				mediaType: 'photo',
				includeBase64: e?.includeBase64 || !1,
				maxWidth: e?.maxWidth || 1024,
				maxHeight: e?.maxHeight || 1024,
				quality: e?.quality || 0.8,
				selectionLimit: e?.selectionLimit || 9,
				...e,
			}
			try {
				return await this.call('chooseImage', t)
			} catch (e) {
				return this.handleError(e, 'Failed to choose image')
			}
		}
		async checkPermission() {
			try {
				return await this.call('checkPermission')
			} catch (e) {
				return this.handleError(e, 'Failed to check camera permission')
			}
		}
		async requestPermission() {
			try {
				return await this.call('requestPermission')
			} catch (e) {
				return this.handleError(e, 'Failed to request camera permission')
			}
		}
	}
	const a = new (class {
		callbacks = new Map()
		modules = {}
		isAvailable = !1
		constructor() {
			'undefined' != typeof window &&
				window.ReactNativeWebView &&
				(this.isAvailable = !0),
				this.setupEventListeners()
		}
		get camera() {
			return this.modules.camera
		}
		get location() {
			return this.modules.location
		}
		get recordAudio() {
			return this.modules.recordAudio
		}
		registerModule(e, t) {
			this.modules[e] = t
		}
		getModule(e) {
			return this.modules?.[e]
		}
		callNative(e, t, r) {
			return new Promise((a, s) => {
				if (!this.isAvailable)
					return void s(new Error('Native bridge not available'))
				const i = `call_${Date.now()}_${Math.random()
						.toString(36)
						.substr(2, 9)}`,
					o = setTimeout(() => {
						this.cleanupCallback(i), s(new Error('Bridge call timeout'))
					}, 3e4)
				this.callbacks.set(i, { resolve: a, reject: s, timeoutId: o })
				const c = {
					type: 'bridge_call',
					callId: i,
					module: e,
					action: t,
					params: r,
					timestamp: Date.now(),
				}
				window.ReactNativeWebView.postMessage(JSON.stringify(c))
			})
		}
		setupEventListeners() {
			window.ReactNativeWebView &&
				document.addEventListener('message', this.handleNativeMessage),
				window.addEventListener('message', this.handleNativeMessage)
		}
		handleNativeMessage = e => {
			try {
				const t = JSON.parse(e.data)
				if ('bridge_response' === t.type) {
					const { callId: e, success: r, data: a, error: s } = t,
						i = this.callbacks.get(e)
					i &&
						(this.cleanupCallback(e),
						r ? i.resolve(a) : i.reject(new Error(s || 'Native call failed')))
				}
			} catch (e) {
				console.error('Failed to handle native message:', e)
			}
		}
		cleanupCallback(e) {
			const t = this.callbacks.get(e)
			t && (clearTimeout(t.timeoutId), this.callbacks.delete(e))
		}
	})()
	a.registerModule('camera', new r(a)),
		a.registerModule(
			'location',
			new (class extends t {
				constructor(e) {
					super(e, 'location')
				}
				async getCurrentPosition(e = {}) {
					const t = { enableHighAccuracy: !1, maximumAge: 0, ...e }
					try {
						return await this.call('getCurrentPosition', t)
					} catch (e) {
						return this.handleError(e, 'Failed to get current location')
					}
				}
			})(a)
		),
		a.registerModule(
			'recordAudio',
			new (class extends t {
				constructor(e) {
					super(e, 'recordAudio')
				}
				async start(e = {}) {
					try {
						return await this.call('start', e)
					} catch (e) {
						return this.handleError(e, 'Failed to start record audio')
					}
				}
				async stop() {
					try {
						return await this.call('stop')
					} catch (e) {
						return this.handleError(e, 'Failed to stop record audio')
					}
				}
				async cancel() {
					try {
						return await this.call('cancel')
					} catch (e) {
						return this.handleError(e, 'Failed to cancel record audio')
					}
				}
				async restart(e = {}) {
					try {
						return await this.call('restart', e)
					} catch (e) {
						return this.handleError(e, 'Failed to restart record audio')
					}
				}
				async checkPermission() {
					try {
						return await this.call('checkPermission')
					} catch (e) {
						return this.handleError(
							e,
							'Failed to check record audio permission'
						)
					}
				}
				async requestPermission() {
					try {
						return await this.call('requestPermission')
					} catch (e) {
						return this.handleError(
							e,
							'Failed to request record audio permission'
						)
					}
				}
			})(a)
		),
		'undefined' != typeof window && (window.h5packBridge = a),
		(e.CameraModule = r),
		(e.default = a),
		(e.h5packBridge = a),
		Object.defineProperty(e, '__esModule', { value: !0 })
})
