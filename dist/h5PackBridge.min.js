!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], t)
    : t(
        ((e =
          'undefined' != typeof globalThis
            ? globalThis
            : e || self).H5PackBridge = {}),
      );
})(this, function (e) {
  'use strict';
  class t {
    h5packBridge;
    moduleName;
    constructor(e, t) {
      (this.h5packBridge = e), (this.moduleName = t);
    }
    async call(e, t) {
      return this.h5packBridge.callNative(this.moduleName, e, t);
    }
    handleError(e, t = 'Operation failed') {
      throw (
        (console.error(`[${this.moduleName}] Error:`, e),
        new Error(e.message || t))
      );
    }
  }
  const a = new (class {
    callbacks = new Map();
    modules = new Map();
    isAvailable = !1;
    constructor() {
      return (
        'undefined' != typeof window &&
          window.ReactNativeWebView &&
          (this.isAvailable = !0),
        this.setupEventListeners(),
        new Proxy(this, {
          get: (e, t) => (e.modules.has(t) ? e.modules.get(t) : e[t]),
        })
      );
    }
    registerModule(e, t) {
      this.modules.set(e, t);
    }
    callNative(e, t, a) {
      return new Promise((s, r) => {
        if (!this.isAvailable)
          return void r(new Error('Native bridge not available'));
        const i = `call_${Date.now()}_${Math.random()
            .toString(36)
            .substr(2, 9)}`,
          n = setTimeout(() => {
            this.cleanupCallback(i), r(new Error('Bridge call timeout'));
          }, 3e4);
        this.callbacks.set(i, {resolve: s, reject: r, timeoutId: n});
        const o = {
          type: 'bridge_call',
          callId: i,
          module: e,
          action: t,
          params: a,
          timestamp: Date.now(),
        };
        window.ReactNativeWebView.postMessage(JSON.stringify(o));
      });
    }
    setupEventListeners() {
      window.ReactNativeWebView &&
        document.addEventListener('message', this.handleNativeMessage),
        window.addEventListener('message', this.handleNativeMessage);
    }
    handleNativeMessage = e => {
      try {
        const t = JSON.parse(e.data);
        if ('bridge_response' === t.type) {
          const {callId: e, success: a, data: s, error: r} = t,
            i = this.callbacks.get(e);
          i &&
            (this.cleanupCallback(e),
            a ? i.resolve(s) : i.reject(new Error(r || 'Native call failed')));
        }
      } catch (e) {
        console.error('Failed to handle native message:', e);
      }
    };
    cleanupCallback(e) {
      const t = this.callbacks.get(e);
      t && (clearTimeout(t.timeoutId), this.callbacks.delete(e));
    }
  })();
  a.registerModule(
    'camera',
    new (class extends t {
      constructor(e) {
        super(e, 'camera');
      }
      async open(e) {
        try {
          return await this.call('open', {});
        } catch (e) {
          return this.handleError(e, 'Failed to open camera');
        }
      }
      async chooseImage(e) {
        try {
          return await this.call('chooseImage', {});
        } catch (e) {
          return this.handleError(e, 'Failed to open camera');
        }
      }
      async checkPermission() {
        try {
          return await this.call('checkPermission');
        } catch (e) {
          return this.handleError(e, 'Failed to check camera permission');
        }
      }
      async requestPermission() {
        try {
          return await this.call('requestPermission');
        } catch (e) {
          return this.handleError(e, 'Failed to request camera permission');
        }
      }
    })(a),
  ),
    'undefined' != typeof window && (window.h5packBridge = a),
    (e.default = a),
    (e.h5packBridge = a),
    Object.defineProperty(e, '__esModule', {value: !0});
});
